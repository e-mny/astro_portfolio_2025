"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vite_1 = require("vite");
const recrawl_sync_1 = require("recrawl-sync");
const imagemin_1 = __importDefault(require("imagemin"));
const imagemin_pngquant_1 = __importDefault(require("imagemin-pngquant"));
const glob_regex_1 = __importDefault(require("glob-regex"));
const chalk_1 = __importDefault(require("chalk"));
const svgo_1 = __importDefault(require("svgo"));
const zlib_1 = __importDefault(require("zlib"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const fsp = fs_1.default.promises;
const mtimeCache = new Map();
const defaultExts = ['html', 'js', 'css', 'svg', 'json'];
const pngExt = /\.png$/;
const svgExt = /\.svg$/;
exports.default = (opts = {}) => {
    const excludeRegex = opts.exclude ? glob_regex_1.default(opts.exclude) : /^$/;
    const extensionRegex = new RegExp('\\.(png|' +
        defaultExts
            .concat(opts.extensions || [])
            .map(ext => ext.replace(/^\./, ''))
            .join('|') +
        ')$');
    let pngOptimizer;
    let svgOptimizer;
    return {
        name: 'vite:compress',
        apply: 'build',
        enforce: 'post',
        configResolved({ root, logger, build: { outDir, ssr } }) {
            if (ssr)
                return;
            const outRoot = vite_1.normalizePath(path_1.default.resolve(root, outDir));
            this.writeBundle = async function () {
                const files = recrawl_sync_1.crawl(outRoot, {
                    skip: ['.DS_Store'],
                });
                const compressed = new Map();
                await Promise.all(files.map(async (name) => {
                    var _a;
                    if (!extensionRegex.test(name) || excludeRegex.test(name))
                        return;
                    const filePath = path_1.default.posix.join(outRoot, name);
                    if (excludeRegex.test(filePath))
                        return;
                    let { mtimeMs, size: oldSize } = await fsp.stat(filePath);
                    if (mtimeMs <= (mtimeCache.get(filePath) || 0))
                        return;
                    let compress;
                    if (pngExt.test(name)) {
                        if (opts.pngquant !== false) {
                            pngOptimizer !== null && pngOptimizer !== void 0 ? pngOptimizer : (pngOptimizer = imagemin_pngquant_1.default(opts.pngquant));
                            compress = content => imagemin_1.default.buffer(content, {
                                plugins: [pngOptimizer],
                            });
                        }
                    }
                    else if (opts.brotli !== false &&
                        oldSize >= ((_a = opts.threshold) !== null && _a !== void 0 ? _a : 1501)) {
                        compress = brotli;
                    }
                    let content;
                    if (opts.svgo !== false && svgExt.test(name)) {
                        content = Buffer.from(await optimizeSvg(filePath));
                    }
                    else if (compress) {
                        content = await fsp.readFile(filePath);
                    }
                    if (content) {
                        if (compress) {
                            content = await compress(content);
                        }
                        await fsp.writeFile(filePath, content);
                        mtimeCache.set(filePath, Date.now());
                        compressed.set(name, 1 - content.byteLength / oldSize);
                    }
                }));
                if (opts.verbose) {
                    logger.info('\nFiles compressed:');
                    const lengths = Array.from(compressed.keys(), name => name.length);
                    const maxLength = Math.max(...lengths);
                    const outDir = path_1.default.posix.relative(root, outRoot);
                    compressed.forEach((ratio, name) => {
                        logger.info('  ' +
                            chalk_1.default.gray(outDir + '/') +
                            chalk_1.default.green(name) +
                            ' '.repeat(2 + maxLength - name.length) +
                            chalk_1.default.blueBright(`${Math.floor(100 * ratio)}% smaller`));
                    });
                    logger.info('');
                }
            };
            if (opts.svgo !== false)
                this.transform = async function (code, id) {
                    var _a;
                    if (svgExt.test(id) && !excludeRegex.test(id)) {
                        const optimized = await optimizeSvg(id);
                        // When the SVG is loaded as a JS module, we need to parse the
                        // file reference so we can update the source code.
                        const fileRef = (_a = /__VITE_ASSET__([a-z\d]{8})__/.exec(code)) === null || _a === void 0 ? void 0 : _a[1];
                        if (fileRef) {
                            this.setAssetSource(fileRef, optimized);
                            return code;
                        }
                        // If no file reference exists, the SVG was inlined.
                        return code.replace(/(;utf8,).+$/, `$1${optimized.replace(/"/g, '\\"')}"`);
                    }
                };
            function brotli(content) {
                var _a;
                const params = {
                    [zlib_1.default.constants.BROTLI_PARAM_MODE]: zlib_1.default.constants.BROTLI_MODE_TEXT,
                    [zlib_1.default.constants.BROTLI_PARAM_QUALITY]: (_a = opts.quality) !== null && _a !== void 0 ? _a : zlib_1.default.constants.BROTLI_MAX_QUALITY,
                    [zlib_1.default.constants.BROTLI_PARAM_SIZE_HINT]: content.byteLength,
                };
                return new Promise((resolve, reject) => {
                    zlib_1.default.brotliCompress(content, { params }, (err, result) => err ? reject(err) : resolve(result));
                });
            }
            async function optimizeSvg(filePath) {
                const content = await fsp.readFile(filePath, 'utf8');
                svgOptimizer !== null && svgOptimizer !== void 0 ? svgOptimizer : (svgOptimizer = new svgo_1.default({
                    plugins: Object.entries({
                        removeViewBox: false,
                        removeDimensions: true,
                        ...opts.svgo,
                    }).map(([name, value]) => ({ [name]: value })),
                }));
                const svg = await svgOptimizer.optimize(content, { path: filePath });
                return svg.data;
            }
        },
    };
};
//# sourceMappingURL=plugin.js.map